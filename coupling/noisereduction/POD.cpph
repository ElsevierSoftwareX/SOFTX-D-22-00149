
template<class LinkedCell,unsigned int dim>
coupling::noisereduction::POD<LinkedCell,dim>::POD(
  const coupling::IndexConversion<dim> &indexConversion,
  const tarch::utils::MultiMDService<dim>& multiMDService
):
coupling::noisereduction::NoiseReduction<LinkedCell,dim>(indexConversion, multiMDService, true),
_timeWindowSize(10),
_kMax(2),
_cycleCounter(0),
_spatialIndex(0),
_t(0),
_data(NULL),
_C(NULL),
_A(NULL),
_A_T(NULL),
_firstTraversal(true)
{
  int spatialSize = getLocalNumberMacroscopicCells(indexConversion);
  _data = new Eigen::MatrixXd[dim+1]; // separate data matrices for: mass, momentum0, momentum1, momentum2
  _C = new Eigen::MatrixXd[dim+1];
  _A = new Eigen::MatrixXd[dim+1];
  _A_T = new Eigen::MatrixXd[dim+1];
  for(unsigned int i=0;i<dim+1;i++){
    _data[i] = Eigen::MatrixXd::Constant(_timeWindowSize, spatialSize, (i==0)?1:0);
  }
}


template<class LinkedCell,unsigned int dim>
coupling::noisereduction::POD<LinkedCell,dim>::~POD(){
  if (_data!=NULL){ delete [] _data; _data=NULL;}
  if (_C!=NULL){ delete [] _C; _C=NULL;}
  if (_A!=NULL){ delete [] _A; _A=NULL;}
  if (_A_T!=NULL){ delete [] _A_T; _A_T=NULL;}
}


template<class LinkedCell,unsigned int dim>
void coupling::noisereduction::POD<LinkedCell,dim>::
beginProcessInnerMacroscopicCells(){
  _spatialIndex = 0;

  if(!_firstTraversal){
    for (unsigned int d = 0; d < dim+1; d++){
      // @todo write this in more efficient iterative form, 
      // updating just one single column instead of everything
      // and compute only lower triangular part!
      _C[d] = _data[d] * _data[d].transpose();  

      // @todo asynchronous allreduce! (but doesnt make sense currently, without interleaved computation)
      #if (COUPLING_MD_PARALLEL==COUPLING_MD_YES)
      double *recv_data = new double[_timeWindowSize*_timeWindowSize];
      MPI_Allreduce(_C[d].data(), recv_data, _timeWindowSize*_timeWindowSize, MPI_DOUBLE, MPI_SUM, 
        coupling::noisereduction::NoiseReduction<LinkedCell,dim>::_multiMDService.getLocalCommunicator());
      Eigen::Map<Eigen::MatrixXd> map(recv_data, _timeWindowSize, _timeWindowSize);
      _C[d] = map;  // copy assignment
      delete [] recv_data;
      #endif

      Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> solver(_C[d]);

      _A[d] = solver.eigenvectors().rightCols(_kMax);
      _A_T[d] = _A[d].transpose();
    }
  }
}


template<class LinkedCell,unsigned int dim>
void coupling::noisereduction::POD<LinkedCell,dim>::
processInnerMacroscopicCell(
coupling::datastructures::MacroscopicCellWithLinkedCells<LinkedCell,dim> &cell, const unsigned int &index){
  if(_firstTraversal){
    // save data into snapshot matrix
    _data[0](_t, _spatialIndex) = cell.getMacroscopicMass();
    for (unsigned int d = 0; d < dim; d++){    // (optimized compiler will unroll this loop)
      _data[d+1](_t, _spatialIndex) = cell.getMacroscopicMomentum()[d];
    }
  } else {
    // compute and store smoothed result
    Eigen::VectorXd phi_x = _A_T[0] * _data[0].col(_spatialIndex);
    cell.setMacroscopicMass((_A[0].row(_t) * phi_x).value());
    tarch::la::Vector<dim,double> mo_smooth;
    for (unsigned int d = 0; d < dim; d++){ // (optimized compiler will unroll this loop)
      phi_x = _A_T[d+1] * _data[d+1].col(_spatialIndex);
      mo_smooth[d] = (_A[d+1].row(_t) * phi_x).value();
    }
    cell.setMacroscopicMomentum(mo_smooth);
  }
  _spatialIndex++;
}


template<class LinkedCell,unsigned int dim>
void coupling::noisereduction::POD<LinkedCell,dim>::
endProcessInnerMacroscopicCells(){
  if(!_firstTraversal){
    _cycleCounter++;
    _t = _cycleCounter%_timeWindowSize;
  }
  _firstTraversal = !_firstTraversal;
}

template<class LinkedCell,unsigned int dim>
unsigned int coupling::noisereduction::POD<LinkedCell,dim>::getLocalNumberMacroscopicCells(const coupling::IndexConversion<dim> &indexConversion) const{
  const tarch::la::Vector<dim,unsigned int> localCells(indexConversion.getLocalNumberMacroscopicCells());
  unsigned int num = localCells[0]; for (unsigned int d = 1; d < dim; d++){ num = num * localCells[d]; }
  return num;
}

/*

* Latenz raus nehmen
- testen, stabilität
- verständnis für library untermauern
- tests / assertions 
- faster calculation of C, performance measurement
* bidirektionale kopplung später einschalten! für initialisierung
- cluster tests
- schon zb nach 90 / 100 MD timesteps filtern?

TODO

* Entwurf Gliederung

genauigkeit
- calc spacial sigma noise, plot profil
- one way coupling with filter results
- compare absolute/relative error: analytic vs filter, plot. compare for several snapshots, serveral k
- one plot per time step
- auswirkungen konfiguration -> stabilität der two way coupling
- oszillierender couette

- csv lb output, python script, cell select, automatisiert

SPÄTER

performance
- identitytransform -> no traversal
- overhead filter?
- scalability with / without filter, MD30 1,8,64   (possibly MD60/->MD120<-)

- multi instance sampling

TELKO Gliederung, Profilplots, TWC-Einschätzung, 16.05. 10:00 040-36949482

----------

couette wall 0

TELKO OWC-Profilplot 23.05. 10:00 Uhr +49 40 460094-236

s

----------------------------


*/
