//Implementation of coupling::indexing::CellIndex

template<unsigned int dim>
void coupling::indexing::testing::printAllBoundaries(std::ostream& os) {
	using coupling::indexing::CellIndex;
	using coupling::indexing::IndexTrait;

		/*
		 * NON-MD-TO-MACRO aka MAMICO INDEXING, INCL GHOST LAYER
		 */
		
		//scalar, global, !md2macro, !noGhost
		os << "CellIndex<dim>: " << std::endl;
		os << "	Lowest: "  << CellIndex<dim>::lowerBoundary << std::endl;
		os << "	Highest: " << CellIndex<dim>::upperBoundary << std::endl;
		os << "	#Cells: "  << CellIndex<dim>::numberCellsInDomain;
		os << " / " << CellIndex<dim>::linearNumberCellsInDomain << std::endl;
		os << std::endl;

		//vector, global, !md2macro, !noGhost
		os << "CellIndex<dim, vector>: " << std::endl;
		os << "	Lowest: "  << CellIndex<dim, IndexTrait::vector>::lowerBoundary << std::endl;
		os << "	Highest: " << CellIndex<dim, IndexTrait::vector>::upperBoundary << std::endl;
		os << "	#Cells: "  << CellIndex<dim, IndexTrait::vector>::numberCellsInDomain;
		os << " / " << CellIndex<dim, IndexTrait::vector>::linearNumberCellsInDomain << std::endl;
		os << std::endl;

				
		//scalar, local, !md2macro, !noGhost
		os << "CellIndex<dim, local>: " << std::endl;
		os << "	Lowest: "  << CellIndex<dim, IndexTrait::local>::lowerBoundary << std::endl;
		os << "	Highest: " << CellIndex<dim, IndexTrait::local>::upperBoundary << std::endl;
		os << "	#Cells: "  << CellIndex<dim, IndexTrait::local>::numberCellsInDomain; 
		os << " / " << CellIndex<dim, IndexTrait::local>::linearNumberCellsInDomain << std::endl;
		os << std::endl;

		
		//vector, local, !md2macro, !noGhost
		os << "CellIndex<dim, vector, local>: " << std::endl;
		os << "	Lowest: "  << CellIndex<dim, IndexTrait::vector, IndexTrait::local>::lowerBoundary << std::endl;
		os << "	Highest: " << CellIndex<dim, IndexTrait::vector, IndexTrait::local>::upperBoundary << std::endl;
		os << "	#Cells: "  << CellIndex<dim, IndexTrait::vector, IndexTrait::local>::numberCellsInDomain;
		os << " / " << CellIndex<dim, IndexTrait::vector, IndexTrait::local>::linearNumberCellsInDomain << std::endl;
		os << std::endl;

		/*
		 * MD TO MACRO, INCL GHOST LAYER
		 */

		//scalar, global, md2macro, !noGhost
		os << "CellIndex<dim, md2macro>: " << std::endl;
		os << "	Lowest: " 	<< CellIndex<dim, IndexTrait::md2macro>::lowerBoundary << std::endl;
		os << "	Highest: " 	<< CellIndex<dim, IndexTrait::md2macro>::upperBoundary << std::endl;
		os << "	#Cells: " 	<< CellIndex<dim, IndexTrait::md2macro>::numberCellsInDomain;
		os << " / " 		<< CellIndex<dim, IndexTrait::md2macro>::linearNumberCellsInDomain << std::endl;
		os << std::endl;

		//vector, global, md2macro, !noGhost
		os << "CellIndex<dim, vector, md2macro>: " << std::endl;
		os << "	Lowest: "  << CellIndex<dim, IndexTrait::vector, IndexTrait::md2macro>::lowerBoundary << std::endl;
		os << "	Highest: " << CellIndex<dim, IndexTrait::vector, IndexTrait::md2macro>::upperBoundary << std::endl;
		os << "	#Cells: "  << CellIndex<dim, IndexTrait::vector, IndexTrait::md2macro>::numberCellsInDomain;
		os << " / " << CellIndex<dim, IndexTrait::vector, IndexTrait::md2macro>::linearNumberCellsInDomain << std::endl;
		os << std::endl;

				
		//scalar, local, md2macro, !noGhost
		os << "CellIndex<dim, local, md2macro>: " << std::endl;
		os << "	Lowest: "  << CellIndex<dim, IndexTrait::local, IndexTrait::md2macro>::lowerBoundary << std::endl;
		os << "	Highest: " << CellIndex<dim, IndexTrait::local, IndexTrait::md2macro>::upperBoundary << std::endl;
		os << "	#Cells: "  << CellIndex<dim, IndexTrait::local, IndexTrait::md2macro>::numberCellsInDomain;
		os << " / " << CellIndex<dim, IndexTrait::local, IndexTrait::md2macro>::linearNumberCellsInDomain << std::endl;
		os << std::endl;

		
		//vector, local, md2macro, !noGhost
		os << "CellIndex<dim, vector, local, md2macro>: " << std::endl;
		os << "	Lowest: "  << CellIndex<dim, IndexTrait::vector, IndexTrait::local, IndexTrait::md2macro>::lowerBoundary << std::endl;
		os << "	Highest: " << CellIndex<dim, IndexTrait::vector, IndexTrait::local, IndexTrait::md2macro>::upperBoundary << std::endl;
		os << "	#Cells: "  << CellIndex<dim, IndexTrait::vector, IndexTrait::local, IndexTrait::md2macro>::numberCellsInDomain;
		os << " / " << CellIndex<dim, IndexTrait::vector, IndexTrait::local, IndexTrait::md2macro>::linearNumberCellsInDomain << std::endl;
		os << std::endl;

		/*
		 * NON-MD-TO-MACRO aka MAMICO INDEXING, EXCL GHOST LAYER
		 */
		
		//scalar, global, !md2macro, noGhost
		os << "CellIndex<dim, noGhost>: " << std::endl;
		os << "	Lowest: "  << CellIndex<dim, IndexTrait::noGhost>::lowerBoundary << std::endl;
		os << "	Highest: " << CellIndex<dim, IndexTrait::noGhost>::upperBoundary << std::endl;
		os << "	#Cells: "  << CellIndex<dim, IndexTrait::noGhost>::numberCellsInDomain;
		os << " / " << CellIndex<dim, IndexTrait::noGhost>::linearNumberCellsInDomain << std::endl;
		os << std::endl;

		//vector, global, !md2macro, noGhost
		os << "CellIndex<dim, vector, noGhost>: " << std::endl;
		os << "	Lowest: "  << CellIndex<dim, IndexTrait::vector, IndexTrait::noGhost>::lowerBoundary << std::endl;
		os << "	Highest: " << CellIndex<dim, IndexTrait::vector, IndexTrait::noGhost>::upperBoundary << std::endl;
		os << "	#Cells: "  << CellIndex<dim, IndexTrait::vector, IndexTrait::noGhost>::numberCellsInDomain;
		os << " / " << CellIndex<dim, IndexTrait::vector, IndexTrait::noGhost>::linearNumberCellsInDomain << std::endl;
		os << std::endl;

				
		//scalar, local, !md2macro, noGhost
		os << "CellIndex<dim, local, noGhost>: " << std::endl;
		os << "	Lowest: "  << CellIndex<dim, IndexTrait::local, IndexTrait::noGhost>::lowerBoundary << std::endl;
		os << "	Highest: " << CellIndex<dim, IndexTrait::local, IndexTrait::noGhost>::upperBoundary << std::endl;
		os << "	#Cells: "  << CellIndex<dim, IndexTrait::local, IndexTrait::noGhost>::numberCellsInDomain; 
		os << " / " << CellIndex<dim, IndexTrait::local, IndexTrait::noGhost>::linearNumberCellsInDomain << std::endl;
		os << std::endl;

		
		//vector, local, !md2macro, noGhost
		os << "CellIndex<dim, vector, local, noGhost>: " << std::endl;
		os << "	Lowest: "  << CellIndex<dim, IndexTrait::vector, IndexTrait::local, IndexTrait::noGhost>::lowerBoundary << std::endl;
		os << "	Highest: " << CellIndex<dim, IndexTrait::vector, IndexTrait::local, IndexTrait::noGhost>::upperBoundary << std::endl;
		os << "	#Cells: "  << CellIndex<dim, IndexTrait::vector, IndexTrait::local, IndexTrait::noGhost>::numberCellsInDomain;
		os << " / " << CellIndex<dim, IndexTrait::vector, IndexTrait::local, IndexTrait::noGhost>::linearNumberCellsInDomain << std::endl;
		os << std::endl;

		/*
		 * MD TO MACRO, EXCL GHOST LAYER
		 */

		//scalar, global, md2macro, noGhost
		os << "CellIndex<dim, md2macro, noGhost>: " << std::endl;
		os << "	Lowest: " 	<< CellIndex<dim, IndexTrait::md2macro, IndexTrait::noGhost>::lowerBoundary << std::endl;
		os << "	Highest: " 	<< CellIndex<dim, IndexTrait::md2macro, IndexTrait::noGhost>::upperBoundary << std::endl;
		os << "	#Cells: " 	<< CellIndex<dim, IndexTrait::md2macro, IndexTrait::noGhost>::numberCellsInDomain;
		os << " / " 		<< CellIndex<dim, IndexTrait::md2macro, IndexTrait::noGhost>::linearNumberCellsInDomain << std::endl;
		os << std::endl;

		//vector, global, md2macro, noGhost
		os << "CellIndex<dim, vector, md2macro, noGhost>: " << std::endl;
		os << "	Lowest: "  << CellIndex<dim, IndexTrait::vector, IndexTrait::md2macro, IndexTrait::noGhost>::lowerBoundary << std::endl;
		os << "	Highest: " << CellIndex<dim, IndexTrait::vector, IndexTrait::md2macro, IndexTrait::noGhost>::upperBoundary << std::endl;
		os << "	#Cells: "  << CellIndex<dim, IndexTrait::vector, IndexTrait::md2macro, IndexTrait::noGhost>::numberCellsInDomain;
		os << " / " << CellIndex<dim, IndexTrait::vector, IndexTrait::md2macro, IndexTrait::noGhost>::linearNumberCellsInDomain << std::endl;
		os << std::endl;

				
		//scalar, local, md2macro, noGhost
		os << "CellIndex<dim, local, md2macro, noGhost>: " << std::endl;
		os << "	Lowest: "  << CellIndex<dim, IndexTrait::local, IndexTrait::md2macro, IndexTrait::noGhost>::lowerBoundary << std::endl;
		os << "	Highest: " << CellIndex<dim, IndexTrait::local, IndexTrait::md2macro, IndexTrait::noGhost>::upperBoundary << std::endl;
		os << "	#Cells: "  << CellIndex<dim, IndexTrait::local, IndexTrait::md2macro, IndexTrait::noGhost>::numberCellsInDomain;
		os << " / " << CellIndex<dim, IndexTrait::local, IndexTrait::md2macro, IndexTrait::noGhost>::linearNumberCellsInDomain << std::endl;
		os << std::endl;

		
		//vector, local, md2macro, noGhost
		os << "CellIndex<dim, vector, local, md2macro, noGhost>: " << std::endl;
		os << "	Lowest: "  << CellIndex<dim, IndexTrait::vector, IndexTrait::local, IndexTrait::md2macro, IndexTrait::noGhost>::lowerBoundary << std::endl;
		os << "	Highest: " << CellIndex<dim, IndexTrait::vector, IndexTrait::local, IndexTrait::md2macro, IndexTrait::noGhost>::upperBoundary << std::endl;
		os << "	#Cells: "  << CellIndex<dim, IndexTrait::vector, IndexTrait::local, IndexTrait::md2macro, IndexTrait::noGhost>::numberCellsInDomain;
		os << " / " << CellIndex<dim, IndexTrait::vector, IndexTrait::local, IndexTrait::md2macro, IndexTrait::noGhost>::linearNumberCellsInDomain << std::endl;
		os << std::endl;
}

template<unsigned int dim, coupling::indexing::IndexTrait ... traits>
void coupling::indexing::testing::checkTrivialConversions() {
	using namespace coupling::indexing::TraitOperations;
	using coupling::indexing::CellIndex;
	using coupling::indexing::IndexTrait;

	//case: vector index type
	if constexpr(std::is_same_v<tarch::la::Vector<dim, int>, typename CellIndex<dim, traits...>::value_T>) { 
		for(int i = 0; i < (int) CellIndex<dim>::linearNumberCellsInDomain; i++) { //for each valid global index
			//construct vector representation
			const auto i_vec = coupling::indexing::convertToVector<dim, traits...>( { i } );
			//check trivial conversion: tested index -> some other index -> tested index == tested index
			try {
				if(CellIndex<dim, traits...> { CellIndex<dim>																					{ CellIndex<dim, traits...> { i_vec } } } != CellIndex<dim, traits...> { i_vec }) 
					throw std::runtime_error("");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::vector>																{ CellIndex<dim, traits...> { i_vec } } } != CellIndex<dim, traits...> { i_vec })
					throw std::runtime_error("vector");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::local>																{ CellIndex<dim, traits...> { i_vec } } } != CellIndex<dim, traits...> { i_vec }) 
					throw std::runtime_error("local");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::vector, IndexTrait::local>											{ CellIndex<dim, traits...> { i_vec } } } != CellIndex<dim, traits...> { i_vec }) 
					throw std::runtime_error("vector, local");

				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::md2macro>																{ CellIndex<dim, traits...> { i_vec } } } != CellIndex<dim, traits...> { i_vec }) 
					throw std::runtime_error("md2macro");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::vector, IndexTrait::md2macro>											{ CellIndex<dim, traits...> { i_vec } } } != CellIndex<dim, traits...> { i_vec }) 
					throw std::runtime_error("vector, md2macro");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::local, IndexTrait::md2macro>											{ CellIndex<dim, traits...> { i_vec } } } != CellIndex<dim, traits...> { i_vec }) 
					throw std::runtime_error("local, md2macro");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::vector, IndexTrait::local, IndexTrait::md2macro>						{ CellIndex<dim, traits...> { i_vec } } } != CellIndex<dim, traits...> { i_vec }) 
					throw std::runtime_error("vector, local, md2macro");

				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::noGhost>																{ CellIndex<dim, traits...> { i_vec } } } != CellIndex<dim, traits...> { i_vec }) 
					throw std::runtime_error("noGhost");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::vector, IndexTrait::noGhost>											{ CellIndex<dim, traits...> { i_vec } } } != CellIndex<dim, traits...> { i_vec }) 
					throw std::runtime_error("vector, noGhost");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::local, IndexTrait::noGhost>											{ CellIndex<dim, traits...> { i_vec } } } != CellIndex<dim, traits...> { i_vec }) 
					throw std::runtime_error("local, noGhost");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::vector, IndexTrait::local, IndexTrait::noGhost>						{ CellIndex<dim, traits...> { i_vec } } } != CellIndex<dim, traits...> { i_vec }) 
					throw std::runtime_error("vector, local, noGhost");

				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::md2macro, IndexTrait::noGhost> 										{ CellIndex<dim, traits...> { i_vec } } } != CellIndex<dim, traits...> { i_vec }) 
					throw std::runtime_error("md2macro, noGhost");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::vector, IndexTrait::md2macro, IndexTrait::noGhost>					{ CellIndex<dim, traits...> { i_vec } } } != CellIndex<dim, traits...> { i_vec }) 
					throw std::runtime_error("vector, md2macro, noGhost");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::local, IndexTrait::md2macro, IndexTrait::noGhost>						{ CellIndex<dim, traits...> { i_vec } } } != CellIndex<dim, traits...> { i_vec }) 
					throw std::runtime_error("local, md2macro, noGhost");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::vector, IndexTrait::local, IndexTrait::md2macro, IndexTrait::noGhost>	{ CellIndex<dim, traits...> { i_vec } } } != CellIndex<dim, traits...> { i_vec }) 
					throw std::runtime_error("vector, local, md2macro, noGhost");
			}
			catch(std::runtime_error& e) {
				using namespace std::string_literals;

				//TODO: more elegant solution
				std::cout << "Last tested global index: " << i_vec << std::endl;

				if constexpr (sizeof...(traits) > 0)
					throw std::runtime_error("("s + print_traitlist<traits...>() + ") -> ("s +  e.what() + ") -> ("s + print_traitlist<traits...>() + ")"s);
				else 
					throw std::runtime_error("() -> ("s +  e.what() + ") -> ()"s);
			}
		}
	}

	//case: scalar index type
	else { 
		for(int i = 0; i < (int) CellIndex<dim>::linearNumberCellsInDomain; i++) { //for each valid global index
			//check trivial conversion: tested index -> some other index -> tested index == tested index
			try {
				if(CellIndex<dim, traits...> { CellIndex<dim>																					{ CellIndex<dim, traits...> { i } } } != CellIndex<dim, traits...> { i }) 
					throw std::runtime_error("");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::vector>																{ CellIndex<dim, traits...> { i } } } != CellIndex<dim, traits...> { i })
					throw std::runtime_error("vector");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::local>																{ CellIndex<dim, traits...> { i } } } != CellIndex<dim, traits...> { i }) 
					throw std::runtime_error("local");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::vector, IndexTrait::local>											{ CellIndex<dim, traits...> { i } } } != CellIndex<dim, traits...> { i }) 
					throw std::runtime_error("vector, local");

				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::md2macro>																{ CellIndex<dim, traits...> { i } } } != CellIndex<dim, traits...> { i }) 
					throw std::runtime_error("md2macro");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::vector, IndexTrait::md2macro>											{ CellIndex<dim, traits...> { i } } } != CellIndex<dim, traits...> { i }) 
					throw std::runtime_error("vector, md2macro");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::local, IndexTrait::md2macro>											{ CellIndex<dim, traits...> { i } } } != CellIndex<dim, traits...> { i }) 
					throw std::runtime_error("local, md2macro");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::vector, IndexTrait::local, IndexTrait::md2macro>						{ CellIndex<dim, traits...> { i } } } != CellIndex<dim, traits...> { i }) 
					throw std::runtime_error("vector, local, md2macro");

				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::noGhost>																{ CellIndex<dim, traits...> { i } } } != CellIndex<dim, traits...> { i }) 
					throw std::runtime_error("noGhost");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::vector, IndexTrait::noGhost>											{ CellIndex<dim, traits...> { i } } } != CellIndex<dim, traits...> { i }) 
					throw std::runtime_error("vector, noGhost");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::local, IndexTrait::noGhost>											{ CellIndex<dim, traits...> { i } } } != CellIndex<dim, traits...> { i }) 
					throw std::runtime_error("local, noGhost");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::vector, IndexTrait::local, IndexTrait::noGhost>						{ CellIndex<dim, traits...> { i } } } != CellIndex<dim, traits...> { i }) 
					throw std::runtime_error("vector, local, noGhost");

				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::md2macro, IndexTrait::noGhost> 										{ CellIndex<dim, traits...> { i } } } != CellIndex<dim, traits...> { i }) 
					throw std::runtime_error("md2macro, noGhost");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::vector, IndexTrait::md2macro, IndexTrait::noGhost>					{ CellIndex<dim, traits...> { i } } } != CellIndex<dim, traits...> { i }) 
					throw std::runtime_error("vector, md2macro, noGhost");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::local, IndexTrait::md2macro, IndexTrait::noGhost>						{ CellIndex<dim, traits...> { i } } } != CellIndex<dim, traits...> { i }) 
					throw std::runtime_error("local, md2macro, noGhost");
				if(CellIndex<dim, traits...> { CellIndex<dim, IndexTrait::vector, IndexTrait::local, IndexTrait::md2macro, IndexTrait::noGhost>	{ CellIndex<dim, traits...> { i } } } != CellIndex<dim, traits...> { i }) 
					throw std::runtime_error("vector, local, md2macro, noGhost");

			}
			catch(std::runtime_error& e) {
				using namespace std::string_literals;

				//TODO: more elegant solution
				std::cout << "Last tested global index: " << i << std::endl;

				if constexpr (sizeof...(traits) > 0)
					throw std::runtime_error("("s + print_traitlist<traits...>() + ") -> ("s +  e.what() + ") -> ("s + print_traitlist<traits...>() + ")"s);
				else 
					throw std::runtime_error("() -> ("s +  e.what() + ") -> ()"s);
			}

		}
	}
}

